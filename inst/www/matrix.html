<!DOCTYPE HTML>
<html>
<head>
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link href="http://fonts.googleapis.com/css?family=Roboto:400,500,300,700" rel="stylesheet" type="text/css">
  <style>
    ::-webkit-scrollbar-track {
  border-radius: 2px;
}

::-webkit-scrollbar {
  width: 5px;
  /*theme primary-1*/
  background-color: #FFF;
}
#container > graphic {
    margin: 4px;
    padding: 2px;
    min-width: 300px;
    background: rgba(0, 0, 0, 0);
    -webkit-flex: 1 6 66%;
    flex: 1 6 66%;
    -webkit-order: 1;
    order: 1;
}
line {
    stroke: rgba(17, 17, 17, 0.19) !important;
}
.background {
    fill: rgba(17, 17, 17, 0) !important;
}
::-webkit-scrollbar-thumb {
  border-radius: 5px;
  -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
  /*theme dividers*/
  background-color: rgba(255, 255, 255, 0.3);
}



ul.test {
    height: 30px;
    width: 150px;
    border: 1px #000 solid;
}
ul.test li { padding: 5px 10px; z-index: 2; }
ul.test li:not(.init) { float: left; width: 130px; display: none; background: #ddd; }
ul.test li:not(.init):hover, ul.test li.selected:not(.init) { background: #09f; }
li.init { cursor: pointer; }

a#submit { z-index: 1; }
h1,
a,
li {
  font-family: Roboto, sans-serif;
}

*focus {
  outline: 1px dotted #333;
}

h1 {
  font-size: 26px;
  background: #9b50ba;
  color: white;
  padding: 40px 0 40px 20%;
  margin-bottom: 50px;
}

a,
li {
  color: #6b6b6b;
  text-decoration: none;
}

.nav {
  margin-left: 20%;
}

.nav > li {
  display: inline-block;
  padding: 1em 18px;
  cursor: pointer;
}

.nav > li:hover {
  background: #ebebeb;
}

#termyear {
  position: relative;
}

#termyear:active,
#termyear:focus,
#termyear:hover,
#termyear:active > option,
#termyear:focus > option,
#termyear:hover > option {
  border-color: #FFF;
  outline: transparent;
}

#termyear > option {
  background: #FFF;
  border: 1px solid pink;
  outline: none !important
}

.drop {
  position: relative;
}

.drop ul,
.drop select {
  position: absolute;
  left: 0;
  top: 3em;
  -webkit-transition: all 0.3s ease;
  transition: all 0.3s ease;
  -webkit-transform: scale(0);
  transform: scale(0);
  -webkit-transform-origin: 0 0;
  transform-origin: 0 0;
  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.16), 0 2px 8px 0 rgba(0, 0, 0, 0.12);
}

.drop ul li,
.drop select option {
  display: block;
  width: 100%;
}

.drop ul li a,
.drop select option {
  width: 100%;
  padding: 1em 18px;
  display: inline-block;
  white-space: pre;
  box-sizing: border-box;
}

.drop ul li a:hover {
  background: #ebebeb;
}

.drop:hover ul {
  -webkit-transform: scale(1);
  transform: scale(1);
}

.follow {
  width: 42px;
  height: 42px;
  border-radius: 50px;
  background: #03A9F4;
  display: block;
  margin: 300px auto 0;
  white-space: nowrap;
  padding: 13px;
  box-sizing: border-box;
  color: white;
  -webkit-transition: all 0.2s ease;
  transition: all 0.2s ease;
  font-family: Roboto, sans-serif;
  text-decoration: none;
  box-shadow: 0 5px 6px 0 rgba(0, 0, 0, 0.2);
}

.follow i {
  margin-right: 20px;
  -webkit-transition: margin-right 0.2s ease;
  transition: margin-right 0.2s ease;
}

.follow:hover {
  width: 134px;
}

.follow:hover i {
  margin-right: 10px;
}

@media screen and (max-width: 800px) {
  .follow {
    margin: 400px auto 0;
  }
}

html,
body,
div,
span,
applet,
object,
iframe,
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote,
pre,
a,
abbr,
acronym,
address,
big,
cite,
code,
del,
dfn,
em,
img,
ins,
kbd,
q,
s,
samp,
small,
strike,
strong,
sub,
sup,
tt,
var,
b,
u,
i,
center,
dl,
dt,
dd,
ol,
ul,
li,
fieldset,
form,
label,
legend,
table,
caption,
tbody,
tfoot,
thead,
tr,
th,
td,
article,
aside,
canvas,
details,
embed,
figure,
figcaption,
footer,
header,
hgroup,
menu,
nav,
output,
ruby,
section,
summary,
time,
mark,
audio,
video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline
}

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
menu,
nav,
section {
  display: block
}

body {
  line-height: 1
}

ol,
ul {
  list-style: none
}

blockquote,
q {
  quotes: none
}

blockquote:before,
blockquote:after,
q:before,
q:after {
  content: '';
  content: none
}

table {
  border-collapse: collapse;
  border-spacing: 0
}

.dropdown {
  outline: none !important
}

#container {
  min-height: 800px;
  margin: 0px;
  padding: 0px;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-flow: row;
  flex-flow: row;
}

#container > graphic {
  margin: 4px;
  padding: 2px;
  min-width: 300px;
  background: #fff;
  -webkit-flex: 1 6 66%;
  flex: 1 6 66%;
  -webkit-order: 1;
  order: 1;
}

#container > aside {
  margin: 4px;
  padding: 5px;
  background: #fff;
  -webkit-flex: 1 6 34%;
  flex: 1 6 34%;
  -webkit-order: 2;
  order: 2;
}

header,
footer {
  display: block;
  margin: 4px;
  /*padding: 5px;*/
  min-height: 50px;
  /*   background: #ffeebb;*/
  font-family: 'Lato', sans-serif;
  font-size: 32px;
  font-weight: 300;
  /*letter-spacing: -2px;*/
  padding: 0em 1em 0 0;
  text-rendering: optimizeLegibility;
  text-align: center;
}


/* Too narrow to support three columns */

@media all and (max-width: 640px) {
  #container,
  #page {
    -webkit-flex-flow: column;
    flex-direction: column;
  }
  #container > article,
  #container > nav,
  #container > aside {
    /* Return them to document order */
    -webkit-order: 0;
    order: 0;
  }
  #container > nav,
  #container > aside,
  header,
  footer {
    min-height: 50px;
    max-height: 50px;
  }
}

.aside {
  color: #525252;
  font: 300 10pt "Lato", sans-serif;
}

#explain {
  font: 400 14pt "Lato", sans-serif;
  height: 110px;
  padding-top: 50px;
}

svg {
  font: 300 10pt 'Lato', sans-serif;
}

.background {
  fill: #eee;
}

line {
  stroke: #fff;
}

text.active {
  text-shadow: 2px 2px 2px yellow;
}
  </style>
</head>

<body style="background-color:#181818">

  <script src="http://d3js.org/d3.v3.js"></script>
 <header>
  <nav>
    <ul class="nav">
    <li><a href="http://www.g.com">Home</a></li>
    <li><a href="http://www.g.com">Portfolio</a></li>
    <li class="drop">Drop
      <ul id="mine">
        <li><a href="http://www.g.com">Art</a></li>
        <li><a href="http://www.g.com">Coding</a></li>
        <li><a href="http://www.g.com">Design</a></li>
        <li><a href="http://www.g.com">Web Development</a></li>
      </ul>
    </li>



    <li><a href="http://www.g.com">Contact</a></li>
  </ul>
   </nav>
  </header>

  <div id="container" style="background-color:#323232 !important;">
    <graphic id="matrix" style="background-color:#212121 !important;"></graphic>
    <aside id="explain-aside" style="background-color:#212121 !important;color:#FFF">
      <div id="explain"></div>
      <!-- explain -->
      <div class="aside">
        <p>
          Year & Term:
          <select id="termyear">
            <option value="2005 Spring">2005 Spring</option>
            <option value="2005 Fall">2005 Fall</option>
            <option value="2006 Spring">2006 Spring</option>
            <option value="2006 Fall">2006 Fall</option>
            <option value="2007 Spring">2007 Spring</option>
            <option value="2007 Fall">2007 Fall</option>
            <option value="2008 Spring">2008 Spring</option>
            <option value="2008 Fall">2008 Fall</option>
            <option value="2009 Spring">2009 Spring</option>
            <option value="2009 Fall">2009 Fall</option>
            <option value="2010 Spring">2010 Spring</option>
            <option value="2010 Fall">2010 Fall</option>
            <option value="2011 Spring">2011 Spring</option>
            <option value="2011 Fall">2011 Fall</option>
            <option value="2012 Spring">2012 Spring</option>
            <option value="2012 Fall">2012 Fall</option>
            <option value="2013 Spring">2013 Spring</option>
            <option value="2013 Fall">2013 Fall</option>
            <option value="2014 Spring">2014 Spring</option>
            <option value="2014 Fall">2014 Fall</option>
            <option value="2015 Spring" selected>2015 Spring</option>
          </select>
          <p>
            Order By:
            <select class="drop" id="order">
              <option value="name">Major Name (Alphabetically)</option>
              <option value="count">Majors that Co-Occur Most Frequently</option>
              <option value="group">Clusters of Co-Occurring Majors</option>
            </select>


      </div>
      <!-- aside -->
    </aside>
    <!-- explain-aside -->
  </div>
  <!-- container -->
  <script>
     // set the dimensions of the graphic
    var margin = { top: 240, right: 0, bottom: 10, left: 200 },
        width = (window.innerWidth * 0.66) - 240,
        height = width,
        orders,
        matrix = [],
        nodeHash = {},
        nodes = [],
        edges = [],
        n; // nodes.length

    // define the scales
    var x = d3.scale.ordinal().rangeBands([0, width]),
        z = d3.scale.linear().domain([0, 18]).clamp(true),
        c = d3.scale.ordinal().range(["#dd2c00","#ff4081","#8c9eff","#18ffff","#ffccbc","#b2dfdb","#212121","#827717","#FFFFFF","#536dfe","#e040fb","#A5D6A7","#1B5E20","#3d5afe"]);

    // add the svg container
    var svg = d3.select("#matrix").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + (margin.left - 20) + "," + (margin.top - 50) + ")");

    // add the explainer text which displays when you mouseover a colored cell
    var explainer = d3.select("#explain").append("foreignObject")
        .attr("width", screen.width * 0.2)
        .attr("height", 200)
      .append("xhtml:text")
        .attr("id", "linklabel")
        .html("<strong>hint:</strong>  mouseover a colored cell<br> to view multiple-major parings");

    d3.csv("https://gist.githubusercontent.com/saraquigley/d6d03ff3e50dc4e01217/raw/7f94bb34a354f059cb9e0043bb606d3a23ad7a60/data.csv", function (error, data) {

        // populate the term dropdown based on the data
        // var termyears = d3.nest()
        //   .key(function(d) { return d.termyear}).sortKeys(d3.ascending)
        //   .rollup(function(leaves) { return leaves.length; })
        //   .entries(data);

       var termyears = ["2005 Spring", "2005 Fall", "2006 Spring", "2006 Fall", "2007 Spring", "2007 Fall", "2008 Spring", "2008 Fall", "2009 Spring", "2009 Fall", "2010 Spring", "2010 Fall", "2011 Spring", "2011 Fall", "2012 Spring", "2012 Fall", "2013 Spring", "2013 Fall", "2014 Spring", "2014 Fall", "2015 Spring"]

       var list = d3.select("#termyear");

        list.selectAll("option")
          .data(termyears)
          .enter()
          .append("option")
          .attr("value", function (d) { return d; })
          .text(function (d) { return d; });

        // set the default to the latest term /y ear
        d3.select("#termyear").property("selectedIndex", "2009 Fall");

        // filter the data by term/year; spring 2015 is the current default
        var filtered_data = data.filter(function (d) {
            return d.termyear === d3.select("#termyear").property('value');
        });

        // The matrix is a grey background
        svg.append("rect")
          .attr("class", "background")
          .attr("width", width)
          .attr("height", height);

        createNetwork(filtered_data);

        // Precompute the orders.
        orders = {
            name: d3.range(n).sort(function (a, b) { return d3.ascending(nodes[a].name, nodes[b].name); }),
            count: d3.range(n).sort(function (a, b) { return nodes[b].count - nodes[a].count; }),
            group: d3.range(n).sort(function (a, b) { return nodes[a].group - nodes[b].group; })
        };

        // The default sort order.
        x.domain(orders.name);

        // Each row is a group of things, such as a white horizontal line, a colored square, and a text label
        var row = svg.selectAll(".row")
            .data(matrix)
          .enter().append("g")
            .attr("class", "row")
            .attr("transform", function (d, i) { return "translate(0," + x(i) + ")"; })
            .each(row); // call a row function to deal with the task of creating a square cell

        row.append("line")
            .attr("x2", width);

        row.append("text")
            .attr("x", -6)
            .attr("y", x.rangeBand() / 2)
            .attr("dy", ".32em")
            .attr("text-anchor", "end")
            .text(function (d, i) { return nodes[i].name.replace(/&amp;/g, '&'); })
            .style("fill", function (d, i) { return c(nodes[i].group); })
            .on("mouseover", mouseover_row)
            .on("mouseout", mouseout_row);

        // each column is also a group containing a line and some text, both rotated -90 degrees
        var column = svg.selectAll(".column")
            .data(matrix)
          .enter().append("g")
            .attr("class", "column")
            .attr("transform", function (d, i) { return "translate(" + x(i) + ")rotate(-90)"; });

        column.append("line")
            .attr("x1", -width);

        column.append("text")
            .attr("x", 6)
            .attr("y", x.rangeBand() / 2)
            .attr("dy", ".32em")
            .attr("text-anchor", "start")
            .text(function (d, i) { return nodes[i].name.replace(/&amp;/g, '&'); })
            .style("fill", function (d, i) { return c(nodes[i].group); })
            .on("mouseover", mouseover_col)
            .on("mouseout", mouseout_col);

        // create the actual colored square cells and color them according to their group.
        function row(row) {
            var cell = d3.select(this).selectAll(".cell")
                .data(row.filter(function (d) { return d.z; }))
              .enter().append("rect")
                .attr("class", "cell")
                .attr("x", function (d) { return x(d.x); })
                .attr("width", x.rangeBand())
                .attr("height", x.rangeBand())
                .style("fill-opacity", function (d) { return d.x == d.y ? 1 : z(d.z); })
                .style("fill", function (d) { return d.x == d.y ? '#fff' : (nodes[d.x].group == nodes[d.y].group ? c(nodes[d.x].group) : '#696969'); })
                .on("mouseover", mouseover)
                .on("mouseout", mouseout)
                .append("title")
                .text(function (d) { return d.x == d.y ? "" : d.z + " multiple majors"; });
        }

        // when the Order By dropdown changes,
        d3.select("#order").on("change", function () {
            // clearTimeout(timeout); // This clears the delay set by WindowTimers.setTimeout ().
            order(this.value);
        });

        // when the Term / Year dropdown changes,
        d3.select("#termyear").on("change", function () {
            var filtered_data = data.filter(function (d) { return d.termyear === d3.select("#termyear").property('value'); });
            createNetwork(filtered_data);
            updateMatrix(matrix);
        });

        function order(value) {
            //re-order the x domain according to the predefined sort orders
            x.domain(orders[value]);

            // set up the transition to last a total of 3 seconds
            var t = svg.transition().duration(3000);

            // have each row and column move after a delay that is a function of the index of its location
            t.selectAll(".row")
                .delay(function (d, i) { return x(i) * 5; })
                .attr("transform", function (d, i) { return "translate(0," + x(i) + ")"; })
              .selectAll(".cell")
                .delay(function (d) { return x(d.x) * 5; })
                .attr("x", function (d) { return x(d.x); });

            t.selectAll(".column")
                .delay(function (d, i) { return x(i) * 5; })
                .attr("transform", function (d, i) { return "translate(" + x(i) + ")rotate(-90)"; });
        }


        // other options for the layout above that don't make the diagonal white:
        // .style("fill-opacity", function(d) { return d.x == d.y ? 0 : z(d.z); })  // make the diagonal grey
        // .style("fill", function(d) { return d.x == d.y ? '#696969' : (nodes[d.x].group == nodes[d.y].group ? c(nodes[d.x].group) :  '#696969');})

        // the row & column labels of the matrix and the square cells all have associated mouseover events
        function mouseover_row(p) {
            var activeCells = d3.selectAll("rect.cell").filter(function (d) {
                return d.y == p[0].y && d.x != d.y;
            }).style('stroke-width', 3).style('stroke', '#64FFDA');
        }

        function mouseout_row(p) {
            d3.selectAll("rect.cell").filter(function (d) {
                return d.y == p[0].y && d.x != d.y;
            }).style('stroke-width', 0);
        }

        function mouseover_col(p) {
            var activeCells = d3.selectAll("rect.cell").filter(function (d) {
                return d.x == p[0].y && d.x != d.y;
            }).style('stroke-width', 3).style('stroke', '#64FFDA');
        }

        function mouseout_col(p) {
            d3.selectAll("rect.cell").filter(function (d) {
                return d.x == p[0].y && d.x != d.y;
            }).style('stroke-width', 0);
        }


        function mouseover(p) {
            var rowtext = d3.selectAll(".row text").filter(function (d, i) { return i == p.y; }),
                coltext = d3.selectAll(".column text").filter(function (d, i) { return i == p.x; });

            d3.selectAll(".row text").classed("active", function (d, i) { return i == p.y; });
            d3.selectAll(".column text").classed("active", function (d, i) { return i == p.x; });

            if (rowtext.text() === coltext.text()) {
                d3.select("#linklabel").html("");
            }
            else {
                d3.select("#linklabel").html(rowtext.text() + ' | ' + coltext.text() + '<br><br><span style="font-size: 18pt;"> ' + p.z + "</span> co-occuring instances");
            }
        }

        function mouseout() {
            d3.selectAll("text").classed("active", false);
            d3.select("#linklabel").html("");
        }


        // take the data output and turn it into a network.
        function createNetwork(edgelist) {
            edges = [], nodeHash = {};
            var nestedEdges, edgelist;

            // account for triple majors,such as cases where a student is triple major in say, econ-math-statistics : the Cal Answers query returns two rows for econ-stat, one for 1st/2nd major, other for 1st/3rd major so combine the two duplicative rows and sum their values.
            nestedEdges = d3.nest().key(function (d) { return d.source + '-' + d.target; }).rollup(function (v) { return d3.sum(v, function (d) { return +d.weight; }); }).entries(edgelist);

            // manipulate the combined data into a network data structure of edges and nodes
            nestedEdges.forEach(function (d) {
                d.source = d.key.slice(0, d.key.indexOf('-'));
                d.target = d.key.slice(d.key.indexOf('-') + 1, d.key.length);
                d.weight = d.values;
            });

            // clean up the data structure and call it edgelist
            edgelist = nestedEdges.map(function (d) { return { 'source': d.source, 'target': d.target, 'weight': d.weight }; });

            // for each edge whose value is greater than 4
            edgelist.forEach(function (edge) {
                if (edge.weight >= 4) {

                    // use nodeHash to keep track of things as the nodes and edges are created
                    if (!nodeHash[edge.source]) {
                        nodeHash[edge.source] = { id: edge.source, name: edge.source };
                        if (nodes.filter(function (d) { return d.name === edge.source; }).length == 0) { nodes.push(nodeHash[edge.source]); }
                    }
                    if (!nodeHash[edge.target]) {
                        nodeHash[edge.target] = { id: edge.target, name: edge.target };
                        if (nodes.filter(function (d) { return d.name === edge.target; }).length == 0) { nodes.push(nodeHash[edge.target]); }
                    }

                    edges.push({ source: nodeHash[edge.source], target: nodeHash[edge.target], weight: edge.weight });

                }
            });

            var newedges = edges.map(function (d) {
                return {
                    'sourceName': d.source.name,
                    'targetName': d.target.name,
                    'source': "",
                    'target': "",
                    'weight': +d.weight
                }
            });
            // remove nodes that don't belong in the array
            // nodes.filter(return function(d) {return d.name === edges;});
            newnodes = [];
            nodes.forEach(function (node, i) {
                var b = newedges.filter(function (d) { return d.sourceName === node.name || d.targetName === node.name; });
                if (b.length > 0) {
                    newnodes.push(node);
                }
            });

            nodes = newnodes;
            nodes.sort(function (a, b) {
                if (a.name > b.name) {
                    return 1;
                }
                if (a.name < b.name) {
                    return -1;
                }
                // a must be equal to b
                return 0;
            });


            // convert the index to numeric for each node
            nodes = nodes.map(function (d, i) { return { name: d.name, index: i }; });

            // add the node id to the nodeHash to create numeric source/target values that the matrix expects
            nodes.forEach(function (node) { nodeHash[node.name] = { id: node.index, name: node.name }; });

            //update the edges with numeric source/target values that the matrix expects
            newedges = edges.map(function (d) {
                return {
                    'sourceName': d.source.name,
                    'targetName': d.target.name,
                    'source': nodeHash[d.source.name].id,
                    'target': nodeHash[d.target.name].id,
                    'weight': +d.weight
                }
            });



            // create the matrix
            createMatrix(nodes, newedges);

        }

        function modularityCensus(nodes, edges) {
            nodes.forEach(function (node) {
                var theseEdges = edges.filter(function (d) { return d.sourceName === node.name || d.targetName === node.name });

                node.majors = d3.sum(theseEdges.map(function (d) { return +d.weight; }));

            });

        }

        function createMatrix(nodes, edges) {
            // reset the matrix
            matrix = [];

            // set up the data for the Louvain method of detecting communities
            var node_data = nodes.map(function (d) { return d.name });
            var edge_data = edges.map(function (d) { return { source: d.sourceName, target: d.targetName, weight: d.weight }; });

            // pass the data to the Louvain algorithm. The logic in an external jsLouvain.js file is what returns the result:
            var community = jLouvain().nodes(node_data).edges(edge_data);
            var result = community();

            // update each node with its group number
            nodes.forEach(function (node) {
                node.group = result[node.name]
            });

            // sum up the total number of edges for each node
            modularityCensus(nodes, edges);

            n = nodes.length;

            // Compute index per node.
            nodes.forEach(function (node, i) {
                node.count = 0;
                matrix[i] = d3.range(n).map(function (j) { return { x: j, y: i, z: 0 }; });
            });

            // Convert edges to a matrix; count major occurrences.
            edges.forEach(function (edge) {
                matrix[edge.source][edge.target].z += edge.weight;
                matrix[edge.target][edge.source].z += edge.weight;
                matrix[edge.source][edge.source].z += edge.weight;
                matrix[edge.target][edge.target].z += edge.weight;
                nodes[edge.source].count += edge.weight;
                nodes[edge.target].count += edge.weight;
            });


            // setTimeout is a web browser function that can be used to execute a code snippet after a specified delay.
            // var timeout = setTimeout(function() {
            // }, 5000);

        } // end ?

        function updateMatrix(matrix) {
            orders = {};

            // Precompute the orders.
            orders = {
                name: d3.range(n).sort(function (a, b) { return d3.ascending(nodes[a].name, nodes[b].name); }),
                count: d3.range(n).sort(function (a, b) { return nodes[b].count - nodes[a].count; }),
                group: d3.range(n).sort(function (a, b) { return nodes[a].group - nodes[b].group; })
            };

            // use the current sort selection
            x.domain(orders[d3.select("#order").property("value")]);

            var rows = svg.selectAll("g.row")
                .data(matrix)
                .each(row);

            rows.select("text")
               .attr("x", -6)
              .attr("y", x.rangeBand() / 2)
              .attr("dy", ".32em")
              .attr("text-anchor", "end")
              .style("fill", function (d, i) { return c(nodes[i].group); })
              .text(function (d, i) {
                  return nodes[i].name.replace(/&amp;/g, '&');
              });

            rows.select("line")
                .attr("x2", width);

            var newrows = rows.enter()
              .append("g")
                .attr("class", "row")
                .each(row);


            newrows.append("line")
              .attr("x2", width);

            newrows.append("text")
                .attr("x", -6)
                .attr("y", x.rangeBand() / 2)
                .attr("dy", ".32em")
                .attr("text-anchor", "end")
                .style("fill", function (d, i) { return c(nodes[i].group); })
                .text(function (d, i) {
                    return nodes[i].name.replace(/&amp;/g, '&');
                });

            rows.exit().remove();

            svg.selectAll("g.row text")
              .on("mouseover", mouseover_row)
              .on("mouseout", mouseout_row);




            // each column is also a group containing a line and some text, both rotated -90 degrees
            var columns = svg.selectAll("g.column")
                .data(matrix)

            columns.enter().append("g")
              .attr("class", "column")
              .attr("transform", function (d, i) { return "translate(" + x(i) + ")rotate(-90)"; })
              .append("text")
              .attr("x", 6)
              .attr("y", x.rangeBand() / 2)
              .attr("dy", ".32em")
              .attr("text-anchor", "start")
              .text(function (d, i) { return nodes[i].name.replace(/&amp;/g, '&'); })
              .style("fill", function (d, i) { return c(nodes[i].group); })
              .on("mouseover", mouseover_col)
              .on("mouseout", mouseout_col);

            columns.append("line")
              .attr("x1", -width);

            columns.exit().remove();

            columns.select("line")
                .attr("x1", -width);

            columns.select("text")
                .attr("x", 6)
                .attr("y", x.rangeBand() / 2)
                .attr("dy", ".32em")
                .attr("text-anchor", "start")
                .text(function (d, i) { return nodes[i].name.replace(/&amp;/g, '&'); })
                .style("fill", function (d, i) { return c(nodes[i].group); })
                .on("mouseover", mouseover_col)
                .on("mouseout", mouseout_col);



            // create the actual colored square cells and color them according to their group.
            function row(row) {
                var cell = d3.select(this).selectAll(".cell")
                     .data(row.filter(function (d) {
                         return d.z;
                     }))
                     // .attr("x", function(d) { return x(d.x); })
                     .attr("width", x.rangeBand())
                     .attr("height", x.rangeBand())
                     .style("fill-opacity", function (d) { return d.x == d.y ? 1 : z(d.z); })
                     .style("fill", function (d) {
                         return d.x == d.y ? '#fff' : (nodes[d.x].group == nodes[d.y].group ? c(nodes[d.x].group) : '#696969');
                     })
                     .on("mouseover", mouseover)
                     .on("mouseout", mouseout)
                     .text(function (d) { return d.x == d.y ? "" : d.z + " multiple majors"; });

                cell.enter().append("rect")
                  .attr("class", "cell")
                  // .attr("x", function(d) { return x(d.x); })
                  .attr("width", x.rangeBand())
                  .attr("height", x.rangeBand())
                  .style("fill-opacity", function (d) { return d.x == d.y ? 1 : z(d.z); })
                  .style("fill", function (d) {
                      return d.x == d.y ? '#fff' : (nodes[d.x].group == nodes[d.y].group ? c(nodes[d.x].group) : '#696969');
                  })
                  .on("mouseover", mouseover)
                  .on("mouseout", mouseout)
                  .append("title")
                  .text(function (d) { return d.x == d.y ? "" : d.z + " multiple majors"; });

                cell.exit().remove();

            }

            // set up the transition to last a total of 3 seconds
            var t = svg.transition().duration(3000);

            // have each row and column move after a delay that is a function of the index of its location
            t.selectAll(".row")
                .delay(function (d, i) { return x(i) * 5; })
                .attr("transform", function (d, i) { return "translate(0," + x(i) + ")"; })
              .selectAll(".cell")
                .delay(function (d) { return x(d.x) * 5; })
                .attr("x", function (d) { return x(d.x); });

            t.selectAll(".column")
                .delay(function (d, i) { return x(i) * 5; })
                .attr("transform", function (d, i) { return "translate(" + x(i) + ")rotate(-90)"; });

            function key(d) { return d.x; }

            // order(d3.select("#order").property("value"));

        } //updateMatrix
    });

    (function () {
        jLouvain = function () {
            //Constants
            var __PASS_MAX = -1
            var __MIN = 0.0000001

            //Local vars
            var original_graph_nodes;
            var original_graph_edges;
            var original_graph = {};
            var partition_init;

            //Helpers
            function make_set(array) {
                var set = {};
                array.forEach(function (d, i) {
                    set[d] = true;
                });
                return Object.keys(set);
            };

            function obj_values(obj) {
                var vals = [];
                for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        vals.push(obj[key]);
                    }
                }
                return vals;
            };

            function get_degree_for_node(graph, node) {
                var neighbours = graph._assoc_mat[node] ? Object.keys(graph._assoc_mat[node]) : [];
                var weight = 0;
                neighbours.forEach(function (neighbour, i) {
                    var value = graph._assoc_mat[node][neighbour] || 1;
                    if (node == neighbour)
                        value *= 2;
                    weight += value;
                });
                return weight;
            };

            function get_neighbours_of_node(graph, node) {
                if (typeof graph._assoc_mat[node] == 'undefined')
                    return [];

                var neighbours = Object.keys(graph._assoc_mat[node]);
                return neighbours;
            }

            function get_edge_weight(graph, node1, node2) {
                return graph._assoc_mat[node1] ? graph._assoc_mat[node1][node2] : undefined;
            }

            function get_graph_size(graph) {
                var size = 0;
                graph.edges.forEach(function (edge) {
                    size += edge.weight;
                });
                return size;
            }

            function add_edge_to_graph(graph, edge) {
                update_assoc_mat(graph, edge);

                var edge_index = graph.edges.map(function (d) {
                    return d.source + '_' + d.target;
                }).indexOf(edge.source + '_' + edge.target);

                if (edge_index != -1)
                    graph.edges[edge_index].weight = edge.weight;
                else
                    graph.edges.push(edge);
            }

            function make_assoc_mat(edge_list) {
                var mat = {};
                edge_list.forEach(function (edge, i) {
                    mat[edge.source] = mat[edge.source] || {};
                    mat[edge.source][edge.target] = edge.weight;
                    mat[edge.target] = mat[edge.target] || {};
                    mat[edge.target][edge.source] = edge.weight;
                });

                return mat;
            }

            function update_assoc_mat(graph, edge) {
                graph._assoc_mat[edge.source] = graph._assoc_mat[edge.source] || {};
                graph._assoc_mat[edge.source][edge.target] = edge.weight;
                graph._assoc_mat[edge.target] = graph._assoc_mat[edge.target] || {};
                graph._assoc_mat[edge.target][edge.source] = edge.weight;
            }

            function clone(obj) {
                if (obj == null || typeof (obj) != 'object')
                    return obj;

                var temp = obj.constructor();

                for (var key in obj)
                    temp[key] = clone(obj[key]);
                return temp;
            }

            //Core-Algorithm Related
            function init_status(graph, status, part) {
                status['nodes_to_com'] = {};
                status['total_weight'] = 0;
                status['internals'] = {};
                status['degrees'] = {};
                status['gdegrees'] = {};
                status['loops'] = {};
                status['total_weight'] = get_graph_size(graph);

                if (typeof part == 'undefined') {
                    graph.nodes.forEach(function (node, i) {
                        status.nodes_to_com[node] = i;
                        var deg = get_degree_for_node(graph, node);
                        if (deg < 0)
                            throw 'Bad graph type, use positive weights!';
                        status.degrees[i] = deg;
                        status.gdegrees[node] = deg;
                        status.loops[node] = get_edge_weight(graph, node, node) || 0;
                        status.internals[i] = status.loops[node];
                    });
                } else {
                    graph.nodes.forEach(function (node, i) {
                        var com = part[node];
                        status.nodes_to_com[node] = com;
                        var deg = get_degree_for_node(graph, node);
                        status.degrees[com] = (status.degrees[com] || 0) + deg;
                        status.gdegrees[node] = deg;
                        var inc = 0.0;

                        var neighbours = get_neighbours_of_node(graph, node);
                        neighbours.forEach(function (neighbour, i) {
                            var weight = graph._assoc_mat[node][neighbour];
                            if (weight <= 0) {
                                throw "Bad graph type, use positive weights";
                            }

                            if (part[neighbour] == com) {
                                if (neighbour == node) {
                                    inc += weight;
                                } else {
                                    inc += weight / 2.0;
                                }
                            }
                        });
                        status.internals[com] = (status.internals[com] || 0) + inc;
                    });
                }
            }

            function __modularity(status) {
                var links = status.total_weight;
                var result = 0.0;
                var communities = make_set(obj_values(status.nodes_to_com));

                communities.forEach(function (com, i) {
                    var in_degree = status.internals[com] || 0;
                    var degree = status.degrees[com] || 0;
                    if (links > 0) {
                        result = result + in_degree / links - Math.pow((degree / (2.0 * links)), 2);
                    }
                });
                return result;
            }

            function __neighcom(node, graph, status) {
                // compute the communities in the neighb. of the node, with the graph given by
                // node_to_com

                var weights = {};
                var neighboorhood = get_neighbours_of_node(graph, node);//make iterable;

                neighboorhood.forEach(function (neighbour, i) {
                    if (neighbour != node) {
                        var weight = graph._assoc_mat[node][neighbour] || 1;
                        var neighbourcom = status.nodes_to_com[neighbour];
                        weights[neighbourcom] = (weights[neighbourcom] || 0) + weight;
                    }
                });

                return weights;
            }

            function __insert(node, com, weight, status) {
                //insert node into com and modify status
                status.nodes_to_com[node] = +com;
                status.degrees[com] = (status.degrees[com] || 0) + (status.gdegrees[node] || 0);
                status.internals[com] = (status.internals[com] || 0) + weight + (status.loops[node] || 0);
            }

            function __remove(node, com, weight, status) {
                //remove node from com and modify status
                status.degrees[com] = ((status.degrees[com] || 0) - (status.gdegrees[node] || 0));
                status.internals[com] = ((status.internals[com] || 0) - weight - (status.loops[node] || 0));
                status.nodes_to_com[node] = -1;
            }

            function __renumber(dict) {
                var count = 0;
                var ret = clone(dict); //deep copy :)
                var new_values = {};
                var dict_keys = Object.keys(dict);
                dict_keys.forEach(function (key) {
                    var value = dict[key];
                    var new_value = typeof new_values[value] == 'undefined' ? -1 : new_values[value];
                    if (new_value == -1) {
                        new_values[value] = count;
                        new_value = count;
                        count = count + 1;
                    }
                    ret[key] = new_value;
                });
                return ret;
            }

            function __one_level(graph, status) {
                //Compute one level of the Communities Dendogram.
                var modif = true,
                    nb_pass_done = 0,
                    cur_mod = __modularity(status),
                    new_mod = cur_mod;

                while (modif && nb_pass_done != __PASS_MAX) {
                    cur_mod = new_mod;
                    modif = false;
                    nb_pass_done += 1

                    graph.nodes.forEach(function (node, i) {
                        var com_node = status.nodes_to_com[node];
                        var degc_totw = (status.gdegrees[node] || 0) / (status.total_weight * 2.0);
                        var neigh_communities = __neighcom(node, graph, status);
                        __remove(node, com_node, (neigh_communities[com_node] || 0.0), status);
                        var best_com = com_node;
                        var best_increase = 0;
                        var neigh_communities_entries = Object.keys(neigh_communities);//make iterable;

                        neigh_communities_entries.forEach(function (com, i) {
                            var incr = neigh_communities[com] - (status.degrees[com] || 0.0) * degc_totw;
                            if (incr > best_increase) {
                                best_increase = incr;
                                best_com = com;
                            }
                        });

                        __insert(node, best_com, neigh_communities[best_com] || 0, status);

                        if (best_com != com_node)
                            modif = true;
                    });
                    new_mod = __modularity(status);
                    if (new_mod - cur_mod < __MIN)
                        break;
                }
            }

            function induced_graph(partition, graph) {
                var ret = { nodes: [], edges: [], _assoc_mat: {} };
                var w_prec, weight;
                //add nodes from partition values
                var partition_values = obj_values(partition);
                ret.nodes = ret.nodes.concat(make_set(partition_values)); //make set
                graph.edges.forEach(function (edge, i) {
                    weight = edge.weight || 1;
                    var com1 = partition[edge.source];
                    var com2 = partition[edge.target];
                    w_prec = (get_edge_weight(ret, com1, com2) || 0);
                    var new_weight = (w_prec + weight);
                    add_edge_to_graph(ret, { 'source': com1, 'target': com2, 'weight': new_weight });
                });
                return ret;
            }

            function partition_at_level(dendogram, level) {
                var partition = clone(dendogram[0]);
                for (var i = 1; i < level + 1; i++)
                    Object.keys(partition).forEach(function (key, j) {
                        var node = key;
                        var com = partition[key];
                        partition[node] = dendogram[i][com];
                    });
                return partition;
            }


            function generate_dendogram(graph, part_init) {

                if (graph.edges.length == 0) {
                    var part = {};
                    graph.nodes.forEach(function (node, i) {
                        part[node] = node;
                    });
                    return part;
                }
                var status = {};

                init_status(original_graph, status, part_init);
                var mod = __modularity(status);
                var status_list = [];
                __one_level(original_graph, status);
                var new_mod = __modularity(status);
                var partition = __renumber(status.nodes_to_com);
                status_list.push(partition);
                mod = new_mod;
                var current_graph = induced_graph(partition, original_graph);
                init_status(current_graph, status);

                while (true) {
                    __one_level(current_graph, status);
                    new_mod = __modularity(status);
                    if (new_mod - mod < __MIN)
                        break;

                    partition = __renumber(status.nodes_to_com);
                    status_list.push(partition);

                    mod = new_mod;
                    current_graph = induced_graph(partition, current_graph);
                    init_status(current_graph, status);
                }

                return status_list;
            }

            var core = function () {
                var status = {};
                var dendogram = generate_dendogram(original_graph, partition_init);
                return partition_at_level(dendogram, dendogram.length - 1);
            };

            core.nodes = function (nds) {
                if (arguments.length > 0) {
                    original_graph_nodes = nds;
                }
                return core;
            };

            core.edges = function (edgs) {
                if (typeof original_graph_nodes == 'undefined')
                    throw 'Please provide the graph nodes first!';

                if (arguments.length > 0) {
                    original_graph_edges = edgs;
                    var assoc_mat = make_assoc_mat(edgs);
                    original_graph = {
                        'nodes': original_graph_nodes,
                        'edges': original_graph_edges,
                        '_assoc_mat': assoc_mat
                    };
                }
                return core;

            };

            core.partition_init = function (prttn) {
                if (arguments.length > 0) {
                    partition_init = prttn;
                }
                return core;
            };

            return core;
        }
    })();

$("ul,test").on("click", ".init", function() {
    $(this).closest("ul.test").children('li:not(.init)').toggle();
});

var allOptions = $("ul.test").children('li:not(.init)');
$("ul.test").on("click", "li:not(.init)", function() {
    allOptions.removeClass('selected');
    $(this).addClass('selected');
    $("ul").children('.init').html($(this).html());
    allOptions.toggle();
});


$("#submit").click(function() {
    alert("The selected Value is "+ $("ul").find(".selected").data("value"));
});
  </script>
</body>
</html>
